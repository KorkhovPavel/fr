Задача: спроектировать и разработать API для системы опросов пользователей.

Функционал для администратора системы:

- авторизация в системе (регистрация не нужна)
- добавление/изменение/удаление опросов. Атрибуты опроса: название, дата старта, дата окончания, описание.
 После создания поле "дата старта" у опроса менять нельзя
- добавление/изменение/удаление вопросов в опросе. Атрибуты вопросов: текст вопроса,
тип вопроса (ответ текстом, ответ с выбором одного варианта, ответ с выбором нескольких вариантов)

Функционал для пользователей системы:

- получение списка активных опросов
- прохождение опроса: опросы можно проходить анонимно, в качестве идентификатора пользователя
в API передаётся числовой ID, по которому сохраняются ответы пользователя на вопросы; один пользователь может
участвовать в любом количестве опросов
- получение пройденных пользователем опросов с детализацией по ответам (что выбрано) по ID уникальному пользователя

Использовать следующие технологии: Django 2.2.10, Django REST framework.

Результат выполнения задачи:
- исходный код приложения в github (только на github, публичный репозиторий)
- инструкция по разворачиванию приложения (в docker или локально)
- документация по API



class Album(models.Model):
    album_name = models.CharField(max_length=100)
    artist = models.CharField(max_length=100)

class Track(models.Model):
    album = models.ForeignKey(Album, related_name='tracks', on_delete=models.CASCADE)
    order = models.IntegerField()
    title = models.CharField(max_length=100)
    duration = models.IntegerField()

    class Meta:
        unique_together = ['album', 'order']
        ordering = ['order']

    def __str__(self):
        return '%d: %s' % (self.order, self.title)

class TrackSerializer(serializers.ModelSerializer):
    class Meta:
        model = Track
        fields = ['order', 'title', 'duration']

class AlbumSerializer(serializers.ModelSerializer):
    tracks = TrackSerializer(many=True)

    class Meta:
        model = Album
        fields = ['album_name', 'artist', 'tracks']

    def create(self, validated_data):
        tracks_data = validated_data.pop('tracks')
        album = Album.objects.create(**validated_data)
        for track_data in tracks_data:
            Track.objects.create(album=album, **track_data)
        return album

      def update(self, instance, validated_data):
        profile_data = validated_data.pop('profile')
        # Unless the application properly enforces that this field is
        # always set, the following could raise a `DoesNotExist`, which
        # would need to be handled.
        profile = instance.profile

        instance.username = validated_data.get('username', instance.username)
        instance.email = validated_data.get('email', instance.email)
        instance.save()

        profile.is_premium_member = profile_data.get(
            'is_premium_member',
            profile.is_premium_member
        )
        profile.has_support_contract = profile_data.get(
            'has_support_contract',
            profile.has_support_contract
         )
        profile.save()

        return instance









class EmployeeEvent(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    event_name = models.CharField(max_length=200)
    start_date = models.DateField()
    end_date = models.DateField()


class EmployeeEvent_Users(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    employee_event = models.ForeignKey(EmployeeEvent, on_delete=models.CASCADE,  related_name='employee_event_employee_list')
    employee = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='employeeEvent_employee')

class EmployeeEventUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = EmployeeEvent_Users
        fields = ('id', 'employee',)

class EmployeeEventSerializer(serializers.ModelSerializer):
    employee_event_users = EmployeeEventUserSerializer( required=True, many=True)

class Meta:
    model = EmployeeEvent
    fields = ('event_name', 'start_date', 'end_date', 'employee_event_users', )


def update(self, instance, validated_data):
    instance.event_name = validated_data['event_name']
    instance.start_date = validated_data['start_date']
    instance.end_date = validated_data['end_date']

    for employee_event_user in validated_data['employee_event_users']:
        employee_event_user_id = employee_event_user.get('employee_id', None)
        if employee_event_user_id:
            emp_user = EmployeeEvent_Users.objects.get(id=employee_event_user_id, employee_event=instance)
            emp_user.employee = employee_event_user.get('employee', emp_user.employee)
            emp_user.save()
        else:
            user = EmployeeEvent_Users.objects.create(employee_event=instance, **employee_event_user)
            user.save()
            instance.employee_event_users.add(user)